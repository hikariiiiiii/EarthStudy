{"./":{"url":"./","title":"首页","keywords":"","body":"EarthStudy 生而为人，学无止境。 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-22 11:14:26 "},"golang/":{"url":"golang/","title":"GO语言","keywords":"","body":"GO语言 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"golang/base.html":{"url":"golang/base.html","title":"语法基础","keywords":"","body":"语法基础 Go语言只有值传递 地址（&）是指针（*）的值，指针是地址的变量 Go语言没有隐式类型转化 Go语言变量类型写在变量名后面 var 包内、函数内 var aa int = 3 var ( aa int = 3 ss = ”kkk” bb = true ) var aa, ss, bb = 3, “kkk”, true 函数内 aa, ss, bb := 3, “kkk”, true 内建类型 bool, string (u)int, (u)int8, (u)int16, (u)int32, (u)int64, uintptr（指针）//(u)int根据操作系统32 64决定位数 byte（8位）, rune（32位） float32, float63, complex64, complex128 const const aa int = 3 const aa, ss, bb = 3, “kkk”, true const( cpp = iota //iota是自增值 _ python java javascript ) iota在const关键字出现时将被重置为0 const中每新增一行常量声明将使iota计数+1（注意在同一行计数不+1） 控制语句 if、for、switch、select 没有while，for即是while 遍历可使用 for i, v := range xxx { } 函数 func function_name( [parameter list] ) [return_types / return parameter list] { defer xxxx return x //若有返回参数名则无需return，直接给返回参数赋值 } Array 数组是值类型，，长度不同类型不同，赋值即拷贝，一般不直接使用数组 var variable_name [SIZE] variable_type variable_name = [SIZE] variable_type{v1, v2, v3} //SIZE为...时根据初始化元素的个数设置大小 Slice 声明： var s []Type //nil 空切片 初始化：” m := []Type{ , , , , } m := make([]Type, len, cap) //len长度，cap可达最大长度 m := a[ s:e] //a可以是已有的slice或数组，前闭后开 //其中e不能大于数组的长度或slice的cap slice的len根据可读元素决定，cap根据开辟的内存决定 读取元素： m[n] //其中n不能超过len-1 遍历： for i, v := range s { } append( s1, v1, v2 ) //若cap不够会重新开辟一个内存，并赋值原值过去 append( s1, s2... ) //...将s2分解为一个个元素 copy(s1, s2) //只将覆盖s1 len范围内的值 len(s) //返回长度 cap(s) //返回可达最大长度 Map var m map[K]V //nil m := map[K]V { k1 : v1 } m := make(map[K]V) //EmptyMap for k, v := range m{ } Map[K]=v value , ok := map[K] //若找不到键值 ok为false delete(map , K) len(m) String、Rune len(string) 返回的是字节长度，可使用utf8.RuneCountString获得字符数量 range遍历string得到的是pos是字节坐标，不适合处理非unicode编码的字符，可先使用[]rune(string)转换后再遍历 go语言支持封装，不支持继承、多态；只有struct没有class 结构体 定义 type StructName struct{ var1 int var2 T } 初始化 var t StructName t = StructName { 1, nil } 使用new函数初始化 t = new(StructName) t.var1 = 1 t.var2 = nil 使用工厂创建函数初始化 func createStruct(var1 int) StructName { return &StructName { var1, nil } //局部变量的地址也可以返回给别人用，内存分配在堆还是栈由编译器决定 } 为结构定义方法： 指针接收者（要改变内容、结构过大、建议有指针接收者则保持一致性也使用指针接收者） func (StructName *t) funcname { } 值接收者 func (StructName t) funcname { } 指针能直接调用方法，当做值来用 nil指针也可以调用方法 包 一个目录下文件只能有同一个包名 main包有一个可执行入口 结构体的方法必须放在同一个包内，但可在不同文件里 扩展系统类型或别人类型： 定义别名 给要扩展的类型创建一个其他名字，再加方法 使用组合 将要扩展的类型放进自己的类型中 Duck Typing 描述事物的外部行为而非内部结构，像鸭子走路，像鸭子叫，像鸭子就是鸭子 严格说go属于结构化类型系统，类似duck typing（duck typing要动态绑定） Python 运行时检查，需要注释来说明接口 C++ 使用模板实现，编译时检查，需要注释来说明接口 Java 没有duck typing，必须实现接口方法，无需注释 接口 接口由使用者定义+组合，实现者无需了解如何组合 接口变量 = {指向的实现者的类型/类型指针，指向的实现者的值/指针} 接口变量可指向实现者的值，也可指向实现者的指针 接口变量蕴含一个指针，故几乎不需要使用接口的指针 若实现的方法为指针接收者，则接口变量必须指向实现者的指针 Type Assertion 转换为指定实现者类型 接口变量.(实现者类型/类型指针) v, ok := i.(int) Type Switch 返回实现者类型/类型指针 接口变量.(type) 返回接口变量指向的实现者类型 switch v := i.(type) { case T1: // TODO case T2: // TODO } 表示任何类型：interface{} Stringer接口 相当于tostring Reader/Writer接口 文件的抽象 嵌入类型 当我们嵌入一个类型，这个类型的方法就变成了外部类型的方法，但是当它被调用时，方法的接受者是内部类型(嵌入类型)，而非外部类型。 函数式编程 函数体 = {局部变量，自由变量} 闭包 = 函数体 + 所有相关自由变量指向的值（递归） 斐波那契数列 为函数实现接口 defer 确保调用在函数结束（return或panic）时发生 参数在defer语句时计算结果 defer列表为后进先出 Open/Close Lock/Unlock PrintHeader/PrintFooter error type error interface{ Error() string } If dError, ok = err.(*ErrorType); !ok{ painc(“unknown err”) } else{ //TODO } panic 尽量不要用 recover 在defer中recover()，来保护panic defer func(){ r := recover() // TODO }() 表格驱动测试 分离测试数据和测试逻辑 更详细的自定义出错信息 可部分失败 Go语言语法更易实现表格驱动测试 单元测试testing.T func TestTriangle(t *testing.T) { tests := []struct{ a, b, c int }{ {3, 4, 5}, {5, 12, 13}, {8, 15, 17}, {12, 35, 37}, {30000, 40000, 50000}, } for _, tt := range tests { if actual := calcTriangle(tt.a, tt.b); actual != tt.c { t.Errorf(\"calcTriangle(%d, %d); got %d; expected %d\", tt.a, tt.b, actual, tt.c) } } } 命令行运行 go test . 代码覆盖率： go test -coverprofile=c.out go tool cover go tool cover -html=c.out 性能测试testing.B func BenchmarkSubstr(b *testing.B) { s := \"黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花\" for i := 0; i for i := 0; i } 命令行运行 go test -bench . 性能分析： go test -bench . -cpuprofile cpu.out go tool pprof cpu.out help web quit http测试： 通过使用假的Request/Response response := httptest.NewRecorder() request := httptest.NewRequest( http.MethodGet, \"http://xxxxxxxxxx\", nil) 通过起服务器 server := httptest.NewServer( http.HandlerFunc(f)) resp, _ := http.Get(server.URL) 文档 命令行运行 go doc 命令行指令帮助 go help doc 启动帮助文档服务器 godoc -http :6060 Example 是另一种测试，也可运行 在给文档提供示例 func ExampleTypename_Funcname() { 函数调用 // 期望的函数返回结果 } goroutine 协程Coroutine： 轻量级“线程” 非抢占式多任务处理，由协程主动交出控制权 编译器/解释器/虚拟机层面的多任务，GO语言有自己的调度器 多个协程可能在一个或多个线程上运行 子程序是协程的一个特例 C++：Boost.Coroutine Java：不支持 Python：使用yield关键字、async def Go语言： go func() { // TODO runtime.Gosched(); //让出控制权 }() 任何加上go就能送给调度器运行 不需要在定义时区分是否是异步函数 调度器会在合适的点进行切换 切换点： I/O，select channel 等待锁 函数调用（有时） Runtime.Gosched() 以上只是参考，不能保证切换，不能保证在其他地方不切换 使用-race来检测数据访问冲突 go run -race xxxx.go channel 类似Python的yield 当一个channel的数据未传输成功时（未发、未收、无缓冲区），当前协程会阻塞等待 var c chan int //可发可收 var c chanc := make(chan int, 3) //创建一个缓冲区大小为3的channel c Go语言channel基于CSP模型 “不要通过共享内存来通信；通过通信来共享内存”，可创建两个channel来完成双向发送数据 WaitGroup 利用WaitGroup判断协程工作是否完毕 var wg = sync.WaitGroup wg.add(1) //添加任务数 wg.done() //完成一个任务 wg.wait() //挂起等待所有任务完成 select 利用select来进行调度，实现非阻塞式获取channel数据，select中若case不可运行且没有default则阻塞直到有case可运行 select { case n:= 传统同步机制 非CPS模型，在GO中尽量少使用 WaitGroup MuteX Cond http标准库 http.Get(“https://xxxxxxxxxxxxxx.com”) request, err := http.NewRequest(http.MethodGet, \"https://xxxxxxxxxxxxxxx.com\", nil) request.Header.Add(“”,””) client := http.DefaultClient() client := http.Client{ xxx : xxx CheckRedirect : func(){ }, } client.Do(request) httputil.DumpResponse(resp, true) http调试： （1） 浏览器访问http服务地址/debug/pprof （2） 命令行go tool pprof 服务地址/debug/pprof/profile获得30秒服务的CPU使用情况 结束后对话输入web （3） 命令行go tool pprof 服务地址/debug/pprof/heap 获得服务的内存使用情况 结束后对话输入web 其他标准库 bufio log encoding/json regexp time string/math/rand 使用 godoc -http:6060 启动帮助文档服务器 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-23 15:39:12 "},"cryptography/":{"url":"cryptography/","title":"密码学","keywords":"","body":"密码学 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"cryptography/hash.html":{"url":"cryptography/hash.html","title":"哈希","keywords":"","body":"哈希 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"cryptography/signature.html":{"url":"cryptography/signature.html","title":"数字签名","keywords":"","body":"数字签名 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"bitcoin/":{"url":"bitcoin/","title":"比特币","keywords":"","body":"比特币 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"bitcoin/decentration.html":{"url":"bitcoin/decentration.html","title":"去中心化","keywords":"","body":"去中心化 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"bitcoin/operation.html":{"url":"bitcoin/operation.html","title":"运行机制","keywords":"","body":"运行机制 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"bitcoin/coin_storage.html":{"url":"bitcoin/coin_storage.html","title":"货币存储","keywords":"","body":"货币存储 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"bitcoin/mine.html":{"url":"bitcoin/mine.html","title":"挖矿","keywords":"","body":"挖矿 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"bitcoin/apply.html":{"url":"bitcoin/apply.html","title":"应用","keywords":"","body":"应用 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"bitcoin/develop.html":{"url":"bitcoin/develop.html","title":"开发","keywords":"","body":"开发 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"ethereum/":{"url":"ethereum/","title":"以太坊","keywords":"","body":"以太坊 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"ethereum/operation.html":{"url":"ethereum/operation.html","title":"运行机制","keywords":"","body":"运行机制 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"ethereum/solidity.html":{"url":"ethereum/solidity.html","title":"Solidity","keywords":"","body":"Solidity Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"ethereum/develop.html":{"url":"ethereum/develop.html","title":"开发","keywords":"","body":"开发 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"hyperledger/":{"url":"hyperledger/","title":"超级账本","keywords":"","body":"超级账本 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"hyperledger/operation.html":{"url":"hyperledger/operation.html","title":"运行机制","keywords":"","body":"运行机制 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"hyperledger/consensus.html":{"url":"hyperledger/consensus.html","title":"共识排序","keywords":"","body":"共识排序 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"hyperledger/ledger_storage.html":{"url":"hyperledger/ledger_storage.html","title":"账本存储","keywords":"","body":"账本存储 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"hyperledger/develop.html":{"url":"hyperledger/develop.html","title":"开发","keywords":"","body":"开发 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"network/":{"url":"network/","title":"网络安全","keywords":"","body":"网络 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"network/protocol.html":{"url":"network/protocol.html","title":"TCP/IP、UDP、HTTP协议","keywords":"","body":"TCP/IP、UDP、HTTP协议 OSI（Open System Interconnect）七层参考模型 物理层 – 数据链路层 – 网络层 – 传输层 – 会话层 – 表示层 – 应用层 网中各节点都有相同的层次 不同节点的同等层具有相同的功能 同一节点内相邻层之间通过接口通信 每一层使用下层提供的服务，并向其上层提供服务 不同节点的同等层按照协议实现对等层之间的通信 物理层协议： 负责0、1 比特流（0/1序列）与电压的高低、逛的闪灭之间的转换。规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性；该层为上层协议提供了一个传输数据的物理媒体，只是说明标准。 在这一层，数据的单位称为比特（bit）（注：bit和字节Byte，我们常说的1字节8位2进制即：1B=8bit）。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45、fddi令牌环网。 数据链路层协议： 负责物理层面上的互联的、节点间的通信传输（例如一个以太网项链的2个节点之间的通信）；该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：ARP、RARP、SDLC、HDLC、PPP、STP、帧中继等。 网络层协议： 将数据传输到目标地址；目标地址可以使多个网络通过路由器连接而成的某一个地址，主要负责寻找地址和路由选择，网络层还可以实现拥塞控制、网际互连等功能。 在这一层，数据的单位称为数据包（packet）。网络层协议的代表包括：IP、IPX、RIP、OSPF等。 传输层协议（核心层）： 传输层是OSI中最重要、最关键的一层,是唯一负责总体的数据传输和数据控制的一层； 传输层提供端到端的交换数据的机制，检查分组编号与次序，传输层对其上三层如会话层等，提供可靠的传输服务,对网络层提供可靠的目的地站点信息主要功能。在这一层，数据的单位称为数据段（segment）。主要功能： ①：为端到端连接提供传输服务。 ②：这种传输服务分为可靠和不可靠的,其中Tcp是典型的可靠传输,而Udp则是不可靠传输。 ③：为端到端连接提供流量控制,差错控制,服务质量(Quality of Service,QoS)等管理服务。 包括的协议如下： TCP：传输控制协议，传输效率低，可靠性强。 UDP：用户数据报协议，适用于传输可靠性要求不高，数据量小的数据。 DCCP、SCTP、RTP、RSVP、PPTP等协议。 会话层协议： 负责建立和断开通信连接（数据流动的逻辑通路），记忆数据的分隔等数据传输相关的管理。 表示层协议：将数据格式转换为标准格式 　　将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式；主要负责数据格式的转换，确保一个系统的应用层信息可被另一个系统应用层读取。具体来说，就是将设备固有的数据格式转换为网络标准传输格式，不同设备对同一比特流解释的结果可能会不同；因此，主要负责使它们保持一致。 应用层协议： ①：超文本传输协议HTTP：这是一种最基本的客户机/服务器的访问协议；浏览器向服务器发送请求，而服务器回应相应的网页。 ②：文件传送协议FTP：提供交互式的访问，基于客户服务器模式，面向连接 使用TCP可靠的运输服务。主要功能:减少/消除不同操作系统下文件的不兼容性。 ③：远程登录协议TELNET：客户服务器模式，能适应许多计算机和操作系统的差异，网络虚拟终端NVT的意义。 ④：简单邮件传送协议SMTP：Client/Server模式，面向连接。基本功能：写信、传送、报告传送情况、显示信件、接收方处理信件。 ⑤：DNS域名解析协议：DNS是一种用以将域名转换为IP地址的Internet服务。 ⑥：简单文件传送协议TFTP：客户服务器模式，使用UDP数据报，只支持文件传输，不支持交互，TFTP代码占内存小。 ⑦：简单网络管理协议（SNMP）: SNMP模型的4个组件：被管理结点、管理站、管理信息、管理协议。SNMP代理：运行SNMP管理进程的被管理结点。 ⑧：DHCP动态主机配置协议: 发现协议中的引导文件名、空终止符、属名或者空,DHCP供应协议中的受限目录路径名 Options –可选参数字段，参考定义选择列表中的选择文件。 TCP/IP（Transmission Control Protocol/Internet Protocol）协议 传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础。包括 ARP，ICMP，IGMP，UDP，以及让域名访问成为可能的DNS，以及电脑/手机可以自动获取IP地址的DHCP，还有形形色色的应用层的协议如 HTTP / SMTP / FTP 等。 通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台电脑规定一个地址。 TCP/IP的四层模型： IP（Internet Protocol）协议 IP协议是将多个包交换网络连接起来，它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。IP协议在OSI参考模型中应用于网络层，以“数据包（Package）”为单位。 IP协议特点 IP协议是一种无连接、不可靠的分组传送服务的协议。 IP协议是点-点线路的网络层通信协议。IP协议是针对原主机-路由器、路由器-路由器、路由器-目的主机之间的数据传输的点-点线路的网络层通信协议。 IP协议屏蔽了网络在数据链路层、物理层协议与实现技术上的差异。：通过IP协议，网络层向传输层提供的是统一的IP分组，传输层不需要考虑互联网在数据链路层、物理层协议与实现技术上的差异，IP协议使得异构网络的互联变得容易了。 IPV4 地址32位，数据报首部的长度是以4个字节为单位，长度可以是20-60字节，这跟首部的HLEN字段有关，格式如下： 首部长度：这个4位字段定义了数据报首部的长度，以4字节的字为单位。当首部没有选项时，首部长度位20字节；当这个字段值位最大值F时，首部长度最大为60字节。 服务类型：在最初这个字段有一部分用于定义数据报的优先级，剩下的一部分定义了服务类型。IETF已经改变了这个8位字段的解释，现在定义了一组区分服务。在这种解释种，前6位构成了码点（codepoint），最后两位未使用。当码点字段最右边的3位不全为0时，这6位定义了54种服务，低延时，高吞吐量等等。 总长度：这个16位字段定义了数据报总长度，其以字节为单位。故IPv4数据报总长度上限值位65536字节。注：为什么需要这个字段？在许多情况下，我们确实不需要这个字段值。但是有些情况下，封装在一个帧里的并不仅仅是数据报，还可能附加了一些填充。比如，以太网协议对帧的数据有最大值（1500字节）和最小值（46字节）的限制，当数据小于46字节时，数据将含有填充数据。 标识（identification）：这个16位字段标志了从源主机发出的一个数据报，这样就确定了数据报的唯一性。这样使得数据报被分片后，在到达终点时终点能根据标识号将同一个数据报的分片重新组装成一个数据报。 标志（flag）：第一位保留（未用），第二位为“不分片（do not fragment）”，第三位位“还有分片（more fragment）”。 分片偏移：这个13位字段表示的是分片在整个数据报中的相对位置。这是数据在原始数据报中的偏移量，以8字节位单位。 生存时间：这个8位字段用来控制数据报所经过的最大跳数（路由器），每经过一个路由器，这个字段数值都减1，减1后变位0时，路由器就丢弃这个数据报。 · 协议：这个8位字段定义了使用IPv4服务的高层协议，如TCP，UDP，ICMP，IGMP，OSPF等的数据都将被封装到IP数据报中。这个字段指明数据报必须交付给哪个最终目的协议。 检验和：检验IP数据报首部。 源地址：定义了源点的IP地址，这个字段始终保持不变。 目的地址：定义了终点的IP地址，这个字段始终保持不变。 IP地址分为A、B、C、D 、E五类，把32位的地址分为两个部分：前面的部分代表网络地址，后面部分是主机地址（局域网地址）。网络掩码(Netmask) 限制了网络的范围，1代表网络部分，0代表设备地址部分。A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验。 A类地址： 1.0.0.1~126.155.255.254，以“0”开始，1字节网络地址3字节主机地址 10.X.X.X是私有地址（在互联网上不使用，而被用在局域网络中的地址） 127.X.X.X是保留地址，用做循环测试用的 默认子网掩码：255.0.0.0 B类地址： 128.0.0.1~191.255.255.254，以“10”开始，2字节网络地址2字节主机地址 默认子网掩码：255.255.0.0 172.16.0.0~172.31.255.255是私有地址 169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器，就会得到其中一个IP C类地址： 192.0.0.1~223.255.255.254，网络地址的最高位必须是“110”，3字节网络地址1字节主机地址 192.168.X.X是私有地址 默认子网掩码：255.255.255.0 D类地址： 224.0.0.1~239.255.255.254，以“1110”开始，不分网络地址和主机地址，用于多点广播 E类地址： 240.0.0.1~255.255.255.254，以“11110”开始，不分网络地址和主机地址，将来使用 IPV6 地址128位， 冒分十六进制表示法： 格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示 0位压缩表示法： 在某些情况下，一个IPv6地址中问可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次。 内嵌IPv4地址表示法： 为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d 报文格式如下： TCP（Transmission Control Protocol）协议 TCP工作在网络OSI的七层模型中的第四层——Transport层（传输层），IP在第三层——Network层，ARP 在第二层——Data Link层。在第二层的数据，我们把它叫Frame（数据帧），在第三层的数据叫Packet（数据包），第四层的数据叫Segment（数据段）。 同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。所以数据的发送和接收其实就是数据的封装和解封装的过程。 TCP报文格式： Source Port和Destination Port：分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程， 而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接； Sequence Number：用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的第一个数据 字节在数据流中的序号；主要用来解决网络报乱序的问题； Acknowledgment Number：32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志(下面介绍)为1时该确认序列号的字 段才有效。主要用来解决不丢包的问题； Offset：给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit(最多能 表示15个32bit的字，即4*15=60个字节的首部长度)，因此TCP最多有60字节的首部。然而，没有任选字段， 正常的长度是20字节； TCP Flags: TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次 为URG，ACK，PSH，RST，SYN，FIN。 URG：此标志表示TCP包的紧急指针域(后面马上就要说到)有效，用来保证TCP连接不被中断，并且督促 中间层设备要尽快处理这些数据； ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0； PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队； RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包； SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1， ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手； Window：窗口大小，也就是有名的滑动窗口，用来进行流量控制。这是一个复杂的问题，本文不再论述。 TCP协议的三次握手： 　　TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。如下图TCP的通信过程所示： 三次握手具体过程（状态）如下（其实可以类比打电话的过程：甲打电话，并等待接听→乙收到来电显示，“并表示可以接听”→“甲收到乙可以接听的信息”，甲接听电话。注：引号部分是打电话过程中没有的，但在TCP三次握手中存在）： 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认。（客户的建立连接并等待确认） 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态。（服务器端发送相关报文段信息并等待连接） 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。（客户的接收到服务端信息并实现连接） 　　然后，客户端和服务端就能实现正常的数据传输啦！ TCP协议的四次分手： 具体过程（状态）如下（同样也可以看做挂电话的过程：我说完了，挂？→我也说完了，挂吧？→好，拜拜→bye。简言之就是确认通信双方都交流完毕再确认断开连接）： 第一次分手：主机1(可以是客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了。（一方数据发送完成） 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了。（另一方数据发送完成） 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态。（请求关闭连接并等待） 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL（Maximum Segment Lifetime，“最长报文段寿命”）后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。（关闭连接） 现在，我们也应该理解为什么TCP协议是面向连接的、可靠的、基于IP协议的“通信控制协议”了。TCP的三次握手保证了数据的可靠性，保证资源不被浪费，而四次分手保证连接的可靠性而不至于随意断开连接，但TCP协议也由其可靠性，数据传输效率变得较低，而不像UDP那样进行实时快速传输。 UDP（User Datagram Protocol）协议 UDP （User Datagram Protocol的简称），用户数据报协议，是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。 与TCP协议一样，UDP协议直接位于IP协议的顶层。根据OSI参考模型，UDP和TCP都属于传输层协议。UDP协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位。每一个数据包的前8个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。 UDP报文格式 与TCP协议不同，UDP协议是非面向连接的不可靠协议，因此没有了SYN等处理两端等待或连接的报文段，相比之下，UDP的报文格式更为简单，主要由报文头（由均16位的源端口号、目的端口号、UDP长度和UDP校验和组成）和具体传输数据组成。如图所示： UDP长度：UDP报文的整个大小，最小为8个字节（16*4位）（仅为首部）。 UDP检验和：在进行检验和计算时，会添加一个伪首部一起进行运算。伪首部（占用12个字节）为：4个字节的源IP地址、4个字节的目的IP地址、1个字节的0、一个字节的数字17、以及占用2个字节UDP长度。这个伪首部不是报文的真正首部，只是引入为了计算校验和。相对于IP协议的只计算首部，UDP检验和会把首部和数据一起进行校验。接收端进行的校验和与UDP报文中的校验和相与，如果无差错应该全为1。如果有误，则将报文丢弃或者发给应用层、并附上差错警告。 UDP特性 UDP是一个无连接协议，传输数据之前源端和终端不建立连接，当 UDP想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。 UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。 UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。 UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。 虽然UDP是一个不可靠的协议，但它是分发信息的一个理想协议。例如，在屏幕上报告股票市场、在屏幕上显示航空信息等等。UDP也用在路由信息协议RIP（Routing Information Protocol）中修改路由表。在这些应用场合下，如果有一个消息丢失，在几秒之后另一个新的消息就会替换它。UDP广泛用在多媒体应用中，例如，Progressive Networks公司开发的RealAudio软件，它是在因特网上把预先录制的或者现场音乐实时传送给客户机的一种软件，该软件使用的RealAudio audio-on-demand protocol协议就是运行在UDP之上的协议，大多数因特网电话软件产品、聊天用的ICQ和QQ也都运行在UDP之上。 TCP协议和UDP协议的区别 1. 一般区别 TCP是面向连接的，传输数据保证可靠性和安全性；UDP协议是非面向连接的，是不可靠但高效率的协议。 TCP占用资源多而UDP占用少。 TCP是流模式而UDP是数据报模式。 TCP是面向连接的，用打电话的过程来类比，就是通信双方是互相明确的，所以进行的是“你一句我一句”的交流，TCP整个通信过程间有一个缓存区，由于通信主体明确，因此可以断断续续地进行交流，数据好比水流，知道源头和目的地，因此称为流模式。反过来，UDP是非面向连接的，好比写信的过程，假设我们只要知道佩奇的地址，我们就能写信给佩奇，而佩奇却不认识我们。这样发起通信方的身份是不明确的，每个发送端的信息都不能和别的发送端混淆，不然会造成数据失效，所以UDP要对数据进行“打包”发送，是面向报文的，就像写信需要用信封套起来，不然只发送数据甚至数据混合会变得毫无意义。 TCP和UDP的应用场景和编程方式也有很大差别。 2. TCP的粘包和UDP的丢包 TCP粘包现象：TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。 粘包原因： 发送端：TCP默认会使用Nagle算法。而Nagle算法主要做两件事：1）只有上一个分组得到确认，才会发送下一个分组；2）收集多个小分组，在一个确认到来时一起发送。所以，正是Nagle算法造成了发送方有可能造成粘包现象。 接收端：TCP接收到分组时，并不会立刻送至应用层处理，或者说，应用层并不一定会立即处理；实际上，TCP将收到的分组保存至接收缓存里，然后应用程序主动从缓存里读收到的分组。这样一来，如果TCP接收分组的速度大于应用程序读分组的速度，多个包就会被存至缓存，应用程序读时，就会读到多个首尾相接粘到一起的包。 粘包处理：如果黏在一起的包是同一个整体，即同意部分数据分割而来的，那么就不用进行处理。如果是不同部分的数据粘到一起，就需要进行粘包解决： 发送端导致：使用TCP_NODELAY选项来关闭Nagle算法。 接收端导致：暂无。 统一解决（应用层）：可以解决接收方造成的粘包问题，还能解决发送方造成的粘包问题。 解决方法就是循环处理：应用程序在处理从缓存读来的分组时，读完一条数据时，就应该循环读下一条数据，直到所有的数据都被处理；但是如何判断每条数据的长度呢？ 两种途径： 　　1）格式化数据：每条数据有固定的格式（开始符、结束符），这种方法简单易行，但选择开始符和结束符的时候一定要注意每条数据的内部一定不能出现开始符或结束符； 2）**发送长度（推荐）**：发送每条数据的时候，**将数据的长度一并发送**，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以**根据长度来判断每条数据的开始和结束**。 UDP丢包现象：丢包现象即使用UDP发送时，由于不可靠连接方式，收到各种因素影响，数据包可能会在接受过程中丢失一部分，从而导致数据不完整。 UDP丢包原因： 发送端：发送的包太大导致send方法无法正常切割为小包导致丢包、发送的包太大超过缓存设置也会出现对包、发送频率太快导致接收端未接受或溢出缓冲区而丢包。 接收端：处理时间过长导致丢包。 其他：网络等问题。 UDP丢包处理： UDP的缺陷在于丢包和乱序问题，一般视情况进行处理，而发送的时候也需要注意上述导致丢包的问题。 HTTP（HyperText Transfer Protocol）协议 HTTP，超文本传输协议，是互联网上应用最为广泛的一种网络协议。所有的万维网WWW（World Wide Web）文件都必须遵守这个标准。 HTTP基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等） HTTP是一个属于应用层的面向对象的协议 HTTP协议工作于客户端-服务端架构为上 HTTP特点 HTTP是一个客户端和服务器端请求和应答的标准，通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行。 HTTP协议的网页 HTTP协议的网页 HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。 通过HTTP或者HTTPS协议（HTTP协议+SSL协议）请求的资源由统一资源标示符（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。HTTP有以下特点： 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 支持B/S及C/S模式。 HTTP的URL地址 URL（UniformResourceLocator，统一资源定位符）是一种特殊类型的URI，包含了用于查找某个资源的足够的信息，是互联网上用来标识某一处资源的地址。 URL的各部分组成： http://www.heyaguang.com:8080/EarthStudy/index.html?var1=1&var2=2#name 协议部分：一般为HTTP或Https，后接//作为分隔符。 域名部分：www.heyaguang.com为网站域名。 端口号部分：此网址为8080。跟在域名后面的是端口号，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口。 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。 文件名部分：从域名后的最后一个“/”开始到后面一个“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.html”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。 参数部分：从“？”开始到“#”为止之间的部分为参数部分。本例中的参数部分为“id=30303&page=2”。不是必要部分。 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。 HTTP请求之request 客户端通过HTTP协议进行请求时遵循一定的格式，请看下面的请求报文格式（由请求行、请求头、空行、请求体组成）： 各部分组成如下所示： HTTP响应之response 在客户端发送请求后服务端进行响应，将信息发送给客户端，以实现功能服务，报文格式如下（包含状态行、响应头、空行、消息体）： HTTP状态码分类： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表： 英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-26 15:51:45 "},"network/consensus.html":{"url":"network/consensus.html","title":"共识算法","keywords":"","body":"共识算法 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"database/":{"url":"database/","title":"数据库","keywords":"","body":"数据库 Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"database/leveldb.html":{"url":"database/leveldb.html","title":"LevelDB","keywords":"","body":"LevelDB Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"database/couchdb.html":{"url":"database/couchdb.html","title":"CouchDB","keywords":"","body":"CouchDB Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"database/mysql.html":{"url":"database/mysql.html","title":"Mysql","keywords":"","body":"Mysql Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-21 22:12:39 "},"markdown/":{"url":"markdown/","title":"Markdown","keywords":"","body":"Markdown Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-22 12:29:09 "},"markdown/markdown.html":{"url":"markdown/markdown.html","title":"markdown语法","keywords":"","body":"Markdown基本语法 一、标题 在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 效果如下： 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 效果如下： 这是加粗的文字 这是倾斜的文字 这是斜体加粗的文字 这是加删除线的文字 三、引用 在引用的文字前加>即可。引用也可以嵌套，如加两个>>三个>>> 示例： >这是引用的内容 >>这是引用的内容 >>>>>>>>>>这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线 三个或者三个以上的 - 或者 * 都可以。 示例： --- ---- *** ***** 效果如下： 可以看到，显示效果是一样的。 --- 五、图片 语法： ![图片alt](图片地址 \"图片title\") 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： ![blockchain](6860761-fd2f51090a890873.webp \"区块链\") 效果如下： 六、超链接 语法： [超链接名](超链接地址 \"超链接title\") title可加可不加 示例： [百度](http://baidu.com) 效果如下： 百度 注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。 超链接名 示例 百度 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 1. 列表内容 2. 列表内容 3. 列表内容 注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格 语法： 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 示例： 姓名|技能|排行 --|:--:|--: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码 语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 (```) 代码... 代码... 代码... (```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 `create database hero;` 代码块 (```) function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); (```) 效果如下： 单行代码 create database hero; 代码块 function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-23 15:49:25 "},"markdown/gitbook.html":{"url":"markdown/gitbook.html","title":"GitBook","keywords":"","body":"GitBook GitBook 是一个使用 Git 和 Markdown 来构建书籍的工具。它可以将你的书输出很多格式：PDF，ePub，mobi，或者输出为静态网页。 Git 方式： 作为一枚程序员，Git 当然是日常生活中的必备工具。使用 Git 的方式去管理文档，除了其自身的优越性外，还大大降低了额外的学习成本，非常便捷。 Markdown：Markdown 的优秀之处可以浓缩为一句：“简单通用，让你只需专注于内容创作”。 多种格式输出：可以一键生成静态文件，非常便于静态站点的搭建。 其他：有丰富的插件、支持多语言、组织结构极为清晰等等。 安装 环境：NodeJS(v4.0.0 及以上) 通过 npm 快速安装。gitbook-cli 一个用于在同一系统上安装和使用多个版本的 GitBook 的管理程序。它将自动安装所需版本的 GitBook 来构建一本书。 $ npm install gitbook-cli -g 安装指定版本： $ gitbook fetch 3.2.3 查看当前安装版本： $ gitbook -V 查看已安装版本： $ gitbook -ls 管理 gitbook-cli 和 gitbook 是两个软件 , 通过 gitbook-cli 来管理 gitbook。 列出 gitbook 帮助信息： $ gitbook help 列出 gitbook-cli 帮助信息： $ gitbook --help 初始化文档结构 (根据 SUMMARY.md 文件生成目录结构)： $ gitbook init 生成 HTML 文件： $ gitbook build 本地预览 (会默认在本地运行 HTTP Server 监听 4000 端口，并生成 HTML 文件至 _book/ ）： $ gitbook serve 使用 目录结构： . ├── book.json ##存放站点配置信息，例如:标题、作者、描述、插件、语言、版本、导航等├── README.md ##书籍的简单介绍├── SUMMARY.md ##定义目录结构的文件，文档左侧的目录就是根据这个文件来生成的，是用Markdown语法来定义目录树的父子关系的。├── Glossary.md ##词汇表文件，用于常用存储词汇信息。├── chapter-1/ | └── something.md └── chapter-2/ └── something.md 案例：Summary.md 文件 # Summary ## 介绍 * [Introduction](README.md)## 文档使用手册 * [简单使用三步走](simple_three_step.md) * [Markdown常用语法](markdown_use.md) * [Gitbook详解](gitbook.md) * [安装](gitbook/install.md) * [命令](gitbook/command.md) * [目录结构](gitbook/structure.md) * [常用插件](gitbook/plugin.md) * [book.json样例](gitbook/book_json.md) * [文档设计](design.md) * [架构逻辑](design/framework.md) * [监控及维护](design/monitor_operation.md) 生成的文件目录结构： ├── book.json ├── design │ ├── framework.md │ └── monitor_operation.md ├── design.md ├── gitbook │ ├── book_json.md │ ├── command.md │ ├── install.md │ ├── plugin.md │ └── structure.md ├── gitbook.md ├── GLOSSARY.md ├── markdown_use.md ├── README.md ├── simple_three_step.md └── SUMMARY.md book.json 样例简介： { \"title\": \"Common\", ##标题 \"description\": \"公共文档\", ##简述 \"author\": \"Common\", ##作者 \"language\": \"zh-hans\", ##语言 \"gitbook\": \"3.2.3\", ##版本 \"root\": \".\", \"structure\": { \"readme\": \"README.md\" }, \"links\": { ##左侧导航栏信息\"sidebar\": { \"Home\": \"xxx\" } }, \"plugins\": [ ##-：表示关闭此插件\"-lunr\", \"-search\", \"highlight\", ##语法高亮\"-livereload\", \"-sharing\", \"search-plus\", ##支持中文搜索 \"simple-page-toc\", ##自动生成本页目录结构 \"advanced-emoji\", ##支持emoji表情 \"anchors\", ##Github 风格的锚点样式 \"include-codeblock\", ##插入代码块 \"ace\", ##支持ace \"emphasize\", ##文字加底色 \"katex\", ##数学公式插件 \"splitter\", ##侧边栏宽度可自由调节 \"tbfed-pagefooter\", ##添加脚页 \"expandable-chapters-small\", ##目录可折叠 \"sectionx\", ##页面分块显示 \"local-video\", ##视频插件(Video.js播放) \"anchor-navigation-ex\", ##悬浮导航 \"todo\", ##ToDo显示功能 \"git-author\", ##显示创建、修改记录 \"alerts\", ##不同alerts样式(info, warning, danger,success) \"include-csv\" ##支持展示csv文件 ], \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true}, \"prism\": { \"css\": [ \"prism-themes/themes/prism-base16-ateliersulphurpool.light.css\" ] }, \"include-codeblock\": { \"template\": \"ace\", \"unindent\": true, \"edit\": true}, \"tbfed-pagefooter\": { \"copyright\": \"Copyright © xiaomi.com 2017\", \"modify_label\": \"文档修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"simple-page-toc\": { \"maxDepth\": 3, \"skipFirstH1\": true}, \"anchor-navigation-ex\": { \"showLevel\": false, \"multipleH1\":true, \"multipleH2\":true, \"multipleH3\":true, \"mode\": \"float\", \"float\": { \"showLevelIcon\": true, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" }, \"pageTop\": { \"showLevelIcon\": true, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" } }, \"sectionx\": { \"tag\": \"b\" }, \"favicon\": { \"shortcut\": \"favicon.ico\", \"bookmark\": \"favicon.ico\" }, \"git-author\":{ \"position\": \"bottom\", \"createTpl\": \"Created by {user}：{timeStamp}\", \"modifyTpl\": \"Modified by {user}：{timeStamp}\", \"timeStampFormat\": \"YYYY-MM-DD\" }, \"styles\": { \"website\": \"./styles/website.css\" }, \"pluginsConfig\": { \"include-codeblock\": { \"template\": \"ace\", \"unindent\": \"true\", \"theme\": \"monokai\" } } } } 可以在本地运行如下命令来分别生成 pdf, epub, mobi 格式文件 gitbook pdf gitbook epub gitbook mobi GitHub Pages GitHub Pages提供静态网站托管服务。 GitHub 上的每个仓库都可以拥有一个 GitHub Pages，对应的 URL 如下： https://.github.io// GitHub Pages 的静态资源支持下面 3 个来源： master 分支 master 分支的 /docs 目录 gh-pages 分支 执行下面命令，将 _book 目录推送到 GitHub 仓库的 gh-pages 分支。 $ git subtree push --prefix=_book origin gh-pages 或者在生成静态网页时，将保存的目录指定为 ./docs $ gitbook build ./ ./docs 然后直接推送到 GitHub 仓库的。 $ git push origin master Copyright © heyaguang.com 2019 all right reserved，powered by Gitbook文档修订时间： 2019-06-22 18:36:19 "}}