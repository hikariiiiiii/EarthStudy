# 运行机制

## 比特币的运行机制

### 比特币的交易

一个交易包含：

1. 比特币的来源

2. 输出地址

   输出地址可以是任意地址，可多个，可用于找零

 

**地址转换**：将比特币转入同一人的不同地址

**有效验证**：不需要从账本建立之初的交易开始核查，只需从引用的输出核查到账本最新记录

**资金合并**：同一人的两笔比特币收入同时作为输入，输出到他的一个地址中

**共同支付**：不同人的比特币作为输入同时作为输入，输出到收款人的地址中，需要多个签名

**交易语法**：

```
元数据	{
		“hash”:”0xxxxxx”
		“ver”:1,
		“vin_sz”:2
		“vout_sz”:1,
		“lock_time”:0,
		“size”:404,
输入		“in”:[
				{
				“prev_out”:{
					“hash”:”1xxxxxx”,
					“n”:0
					},
				“scriptsig”:”...”
				}
				{
				“prev_out”:{
					“hash”:”2xxxxxx”,
					“n”:0
					},
				“scriptsig”:”...”
				},
			]
输出		“out”:[
				{
				“value”:”xxx”,
				“scriptPubKey”:”OP_DUP OP_HASH160 3xxxxxx OP_EQUALVERIFY OP_CHECKSIG”
				}
			]
		}
```
输入总金额 – 输出总金额 = 记账交易费



**根据目标地址区分的交易类型：**

1. 支付到公钥Hash，Pay-To-PubkeyHash Tx .（**P2PKH** Tx）
2. 支付到脚本Hash，Pay-To-ScriptHash Tx .（**P2SH** Tx）
3. 挖矿交易（coinbase）



### 比特币的脚本

可以为比特币支付设定条件

**堆栈式编程语言（stack-based programming language）**，非图灵完备（避免无限循环）

和Forth语言有很多相似的地方

将输入脚本和输入比特币的前一笔交易的输出脚本链接起来，然后执行

一共只有256个指令，每个指令一个字节（目前15个不可用，75个保留）

包含其他语言里常见的基本指令（基本算数、逻辑语句、抛出错误、过早返回）

包含一个重要的特殊指令（CHECKISIG）可查证多个签名，该指令有一个缺陷即会返回一个没用的值，它要求堆栈的一个变量去储存然后忽略，这个缺陷也是比特币的一个特性

脚本在交易的时候执行

脚本分两类：

1. 数据指令（<>），作用是把数据推到堆栈的最上面

2. 工作码指令，用堆栈顶部的数据作为输入值，用来计算一个函数

 

### 比特币脚本的应用

**销毁证明（proof of burn）**：用于销毁比特币（防止资金被赎回）

使用OP_RETURN直接抛错

 

**P2SH**：对堆栈顶部数据进行哈希运算，核验哈希结果与另一个给定的哈希值一致，通过后将最顶层的数据重新解读为一系列指令，然后运行一次这些指令，此时堆栈中的其他数据作为脚本的输入值

P2SH简化了支付工作，收款方只需告诉付款方一个哈希值，无需付款方写入复杂的脚本；还提升了挖矿效率

 

**第三方支付交易（escrow transation）**

使用多重签名（MULTISIG）实现，加入第三方仲裁员，三人中有两人签名后资金才能被支取

场景：货到付款&见款发货&退款

 

**绿色地址（green address）**

即第三方银行（可以是交易所或者其他金融媒介）控制的账户，第三方银行保证不会双重支付，故收款人无需等待区块链的6次确认

绿色地址使用的越来越少，人们认为，对“银行”过分信任是有风险的

 

**高效小额支付（efficient micro-payments）**

使用多重签名（MULTISIG）实现，需要收款人和付款人两个签名才能完成交易，如此可允许短时间重复支付，收款人在所有支付结束后再签名完成交易，可减少交易次数（交易费），而重复支付没有签名的那些交易会被丢弃掉

步骤：

1. 付款人创建一个交易到MULTISIG，金额为可能花费的最大金额，MULTISIG需要收付款两方的签名才能使用
2. 在付款人发布步骤1的交易之前，要求收款人先发布一个从MULTISIG退款给付款人的交易，该交易的lock_time=t，t>0，即t时间后才计入区块链
3. 在有退款交易的保证下，付款人发布步骤1的交易
4. 付款人在每次需要小额支付的时候签名一个从MULTISIG到收款人的交易，金额为所有累计的费用，剩余金额转给付款人自己
5. 消费结束时付款人签名最后一个交易，同时收款人在最后一个交易上签名

场景：手机流量提供商根据每分钟使用的流量计费

 

**锁定时间**

利用lock_time防止小额支付中的收款人一直不签名，而扣押了付款人的剩余比特币

lock_time是一个非零数值t，告诉矿工记账时候，要等到t时间之后才将交易记入区块链

 

**智能合约**

即无需通过法律或者仲裁机构来保护执行的普通合约，

比特币的特性能用脚本、矿工和交易验证来实现第三方托管协议或是小额支付

但比特币脚本语言的设计也有很多缺陷，有很多现实需求无法实现，因此需要像以太坊等实现了图灵完备的智能合约

 

### 比特币的区块

1. 区块的哈希链，每个区块都有一个区块头部，里面有

   一个哈希指针指向上一个区块（prev）

   一个矿工可修改的“临时随机数”（nonce）

   一个时间戳

   一个点数（表示找到区块的难度）

2. 梅克尔树（树状数据结构），把区块内所有交易的哈希值进行排列存储

   梅克尔树中都有一个币基交易

 

**币基交易（coinbase）**

1. 永远只有一个单一的输入与单一的输出
2. 交易不消费之前交易输出的比特币，因此没有指针指向“上一交易”
3. 输出的值 = 区块奖励 + 区块中所有交易费
4. 币基交易的参数可以是任何数据，矿工可以放任何值进去 



### 比特币的网络

**泛洪算法（flooding algorithm）/八卦协议（gossip）**

1. 发起交易
2. 传播给其他相连节点
3. 节点接收到交易后进行核验
4. 节点判断若交易池中没有该交易则放入交易池并继续传播给其他相连节点，否则中止传播

泛洪算法的效率偏低（比较大的区块需要30秒左右才能传播到大部分节点）



**节点核验交易的四个关卡**

1. 交易验证，找到所有输入的前序交易的输出脚本来核验，确保所有结果都为真
2. 检查是否有双重支付
3. 检查是否已经被本节点接收过
4. 只接收和传递在白名单上的标准脚本

上述检查都是非强制的

 

**竞态条件（race condition）/紊乱情况**：众多节点对哪些交易应该被纳入区块链产生分歧

该情况会被打包下一个节点的矿工打破

 

**比特币网络大小**：很难测量，因为随时都在变化。

往低说5000-10000节点永远在线并处理交易，往高说有100万个IP成为节点

 

**存储空间需求**：需要将整个完整的共识区块链存储下来，并将所有未被消费的比特币的完整列表放在内存中以便快速验证

 

**轻量节点（lightweight nodes）/轻客户端/简单付款验证（Simple Payment Verification, SPV）**:

不存储整个比特币区块链，而只存储它们关心的、需要核验的部分交易

依赖全节点去验证全部交易，但在矿工挖出来之前会做一些核验来确保这个区块不会被拒绝

 

### 限制与优化

##### 更新协议：硬分叉、软分叉

硬分叉：新的特性会使前一版本的协议失效，网络上的节点根据其所运行的协议版本去扩展不同的区块链，分叉不会合并，该情况是比特币社区不能接受的

软分叉：新的特性让现有核验规则更加严格，这样老节点会接受所有区块，新的节点会拒绝一些，能避免永久分裂；可以说更新后的新交易和新区块在旧协议下是有效的，新协议是原协议的一个子集