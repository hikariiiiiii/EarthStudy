# 挖矿

### 矿工的任务

（一类是验证交易和区块，一类是和其他矿工竞争）

一类是和其他矿工竞争

1. 监听交易广播

2. 维护区块链网络和监听新的区块

3. 组装一个备选区块

4. 找到新区块对应的有效的随机数

   先尝试头部的临时随机数，若试过所有32位可能的取值后仍然不能产生一个有效的哈希值，还可以改动币基里的随机数，但后者改动涉及到梅克尔树的更新，代价更大

   2015年目标区域值为：

   小于 0000000000000000172EC0000000000000000000000000000000000000000000

5. 新区块被全网接受
6. 获得利润



决定难度：每挖出2016个区块（约两周时间）则所有矿工自己重新计算一次难度

下一个难度 = 上一个难度 x 2016 x 10 / 产生上2016个区块所花费的分钟

 

### 挖矿所需硬件

挖矿设备：

1. CPU挖矿非常困难
2. GPU的高吞吐量和高并行处理能力更适合用于挖矿，且大多数显卡支持超频，能家加快运算速度；OpenCL是一个可以使GPU进行非图像处理类工作的通用语言；但是GPU内置了很多与挖矿无关的硬件，同时还有耗电多、散热难等问题；GPU挖矿的运算速度仍然 
3. 现场可编程门阵列挖矿（Field-Programmable Gate Array,FPGA）+Verilog（硬件设计语言），优点是比GPU性能好、容易冷却，缺点是性能提升不大、一直超频导致报错和故障、算法优化难、采购搭建难，故短暂存在后便退出舞台
4. 专用集成电路技术挖矿（ASIC），主导当今挖矿市场



大型专业挖矿中心，建立的三个重要因素：气候、电费、网络接入速度



新的另类币总会经历一个ASIC蜜月期（还没有ASIC的时期，个人参与挖矿的利润比较高）

 

### 能源消耗和生态环保

**蓝道尔原理（Landauer’s principle）**：任何一个不可逆转的计算都会消耗一定的能源

任何位移运算都会消耗一定量（kTln2）的焦耳

比特币的能源消耗：

1. 内涵能源：设备的制造和运输消耗的能源，会越来越小
2. 电能：根据蓝道尔原理，是不可避免的
3. 冷却：一般也是利用电力，寒冷环境可以减少消耗

 

比特币的能耗预估：

自上而下：将所有区块奖励的收入都用于电费来计算

自下而上：利用算力除以矿机功效来计算

得到比特币挖矿大搞所耗电力为几百万瓦特（MW）的数量级

 

### 矿池

总的发现区块的期望值可以是泊松概率分布

 

**矿池**：一组矿工形成一个矿池共同进行挖矿，并指定同一个币基接受人，最终无论谁发现了有效区块，币基接受人都根据每个参与者所贡献的工作量按比例分配奖励

**挖矿工分（mining shares）**：那些接近目标值的区块

**工分分红**：矿工发送工分后，管理员马上对其支付奖励；对矿工最有利，管理员需要承担风险但也会收取更高的管理费用；矿工没有动力追求有效区块

**按实际比例分红**：当找到一个有效区块时，将奖励按矿工的实际工作量比例分配；降低了管理员的风险但要求管理员校验、计算和分配奖励；矿工有动力追求有效区块；矿池足够大时，发现有效区块的概率波动会相当低

获取有效区块模板（getblocktemplate，GBT）作为一种标准化的矿池协议放进了比特币改进方案（Bitcoin Improvement Proposal，BIP）中。一种被称为层（stratum）在实际中运用广泛

**矿池跳换（pool hopping）**：矿工通过切换矿池的方式提高自己的收益。例如在挖矿周期的早期（上一个区块刚刚被发现），在按实际比例分红的矿池中挖矿，只在周期的后期切换到一个工分分红模式的矿池

**洗算力（laundering hashes）**：大的挖矿机构通过同时参与多个不同的矿池来掩盖他们的真实规模

 

### 挖矿的激励和策略

**挖矿策略**：

1. 需要包括哪些交易？默认选择交易费比较高的交易
2. 在哪一个区块上进行挖矿？默认是在最长的那条区块链上继续挖下去
3. 若两个不同的区块在同一时间被宣布发现，该如何做选择？默认选择最先被监听到的那个区块
4. 什么时候宣布新的区块？默认立刻宣布

大部分矿工都选择了默认策略（default strategy）来挖矿

 

### 挖矿攻击

**分叉攻击（forking attack）**：利用分叉制造双重支付

设一个攻击者矿工掌握的比特币网络挖掘市场份额为ａ，如果ａ>0.5，很可能实现一个分叉攻击，拥有近乎50%算力的攻击者可能需要花很长时间，但算力超过50%越多，攻击就会越容易且越有效

可操作的对策：大家可以觉察到攻击，社区可以对此做出决定，即使分叉链更长也可以拒绝接受

这种攻击能摧毁比特币信心，使其没有价值，可被称为金手指攻击（Goldfinger attack）；攻击者可以做比特币空头交易或拥有大量竞争货币而获益

 

**通过贿赂进行分叉攻击**：系统外的贿赂、高奖励矿池、高额交易费

 

**临时保留区块攻击（temporary block-whihholding attacks）**：找到有效区块后不立刻宣布而是在新区快上继续挖矿，期望可以在其他矿工找到下一个区块之前连续找到两个有效区块，该行为称为自私挖矿（selfish mining）

 

**惩罚分叉攻击（punitive forking）**：宣布拒绝在包含来自该地址的交易的区块链上工作，若宣布者市场运算能力大，则其他矿工会为了避免自己的区块链被分叉而不将该交易放入区块链中

 

**羽量级分叉攻击（feather forking）**：当算力不足0.5时，通过宣布将会尝试分叉来封杀某个地址，若其他矿工相信你，也可能会为了避免自己的区块链被分叉而决定加入你的封杀行动

 

### 好的挖矿算法

挖矿解谜更精确的说法是**“不完全哈希函数原像解谜”（partial hash-preimage puzzle）**

一个好的解谜方案：

1. 能够被及时验证
2. 解谜难度可调整
3. 给每个矿工按哈希算力的比例来获得谜底，即解谜是“无关过程”（progress free）的

上面也是比特币挖矿解谜的三大核心特征

4. 永不枯竭的解谜库

5. 谜题通过算法自动生成

 

### 反ASIC解谜

**反ASIC解谜（ASIC-resistance puzzles）**：抑制ASIC设备优势的解谜程序

**刚性内存解谜（memory-hard puzzles）**：一种需要大量的内存来计算的反ASIC解谜

**Scrypt**是一个刚性内存的哈希函数，先用随机数填充随机存取存储器（Random Access Memory，RAM）里的缓存空间，然后从这块内存区域里虚拟随机地读取（或更新）数据，同时要求整个缓存都存储在RAM里面，伪代码：

```
       def scrypt( N , seed ):
       V = [0]*N                     //初始化N长度的缓存区域
       //往缓存区域里充满虚拟随机数
       V[0] = seed
       For i = 1 to N:
              V[i] = SHA-256(V[i-1])
       //然后从这个区域里虚拟随意地读取
       X = SHA-256(V[N-1])
       For i = 1 to N:
              j = X % N              //根据X，选择一个随机的索引
              X = SHA-256(X ^ V[j])  //根据X的索引来更新这个X
       return X
```

若不使用缓存V，时间复杂度为O(N2)

若使用缓存V，时间复杂度为O(N)

故只要N值足够大，就能确保使用内存是更快的选择

另外还可以只缓存一部分来平衡时间与内存：假设储存缓存区域V里的每个k排数据，则大致内存为N/k，SHA-256迭代计算次数为( k + 3 )N/2

Scrypt的一个局限性是需要用同样大小的内存来校验，增加了分叉攻击的风险

Scrypt在**莱特币**的实际应用由于N值较低中最终无法反ASIC

 

**布谷鸟周期算法**：于2014年提出，需要建立一个很大的哈希表来计算周期，但结果却可以通过发现一个相对小的周期来验证

 

**X11**：将11个不同的哈希函数结合在一起的反ASIC解谜方案，被应用在黑暗币（DASH）中，其反ASIC的方式并不科学

 

### 有效工作量证明

**有效工作量证明**：让比特币挖矿的工作量证明所消耗的能量对社会做出贡献



**质数币（Primecoin）**：被证明具有有效工作的系统，其工作量证明是为质数找到一个“坎宁安链”

**坎宁安链（Cunningham chain）**：k个质数的序列P1,P2,…,Pk，使得Pk = 2 Pi-1 + 1

质数币解谜算法：

> 三个关键参数m，n，k
>
> 对于解谜挑战x（上一个区块的哈希函数值），要找到一个长度为k的坎宁安链，其中第一个质数的位数是n，且它的前 m位数与x的前m位数相同（n>=m）；增加n的值可使问题难度指数型增长，增加k的值可使问题难度线性增长，m足够大使得知道前一个区块的值之前的预先计算没有意义

局限性是坎宁安链还没有实际的应用和解谜结果验证时间长

 

**存储量证明（proof of storage）/可恢复性证明（proof of retrievabitlity）**：一个需要本地存储大量数据用来运算的解谜算法

**永久币（Permacoin**）：用于共识机制的存储量证明方案

首先系统选择一个不变的有意义的大文件F，并用一个大型梅克尔树代表F，挖矿步骤如下：

1. 矿工生成一个用于接受资金的公钥KM
2. 矿工使用KM进行哈希运算生成的一个随机索引集，对应梅克尔树的区块集FM ⊆ F，区块数为k1
3. 矿工存储FM到本地以实现挖矿（也可存储一部分，用运算时间换取存储空间）
4. 矿工获得区块链前一个区块的哈希值s时，创建一个临时随机数n
5. 矿工使用s、KM、n行哈希运算生成的一个随机索引集，对应k1个区块FM中的k2个区块FM, n（k2 < k1）
6. 最后矿工对n、FM, n进行SHA-256的哈希函数H( FM, n || n )运行，如果计算结果低于目标难度，则挖矿成功（与比特币相同）

校验结果步骤如下：

1. 校验FM, n是由矿工的公钥KM和临时随机数n共同产生
2. 通过梅克尔树检验FM, n中的每一个区块时正确的
3. 校验H( FM, n || n )的值比目标难度要小（**为何不把s放进哈希函数？**）

若k2足够大，降低存储量带来的计算负担是指数型增长的，故矿工没法通过降低存储量来权衡成本；但太大的k2会增加校验结果的成本

若k1更小以为这挖矿更加民主化；但有能力存储更多的矿工没有动力存储多于k1的区块

 

### 反矿池解谜：不能外包的解谜算法

矿池依赖于比特币的两大技术特征：

1. 矿工很容易通过工分来证明工作量（由于谜题本身就需要包含难度可调整的特征，故很难通过改变此特征来反矿池）
2. 矿池成员可以容易地保证遵守规则并通过实际运算来寻找有效区块，最后让整个矿池受益

反矿池的方案有：

1.  “区块丢弃”攻击（block-discarding attack）：矿池成员在找到有效区块时不提交给管理员，而是直接丢弃

   设计一个挖矿解谜算法使得“区块丢弃”攻击有利可图，从而抵抗矿池存在

2. 奖励破坏：让分配奖励的过程无法可靠进行

   设计一个挖矿解谜算法将私钥加入到运算中，如先用私钥对区块进行数字签名。在这种解谜算法下，解谜者即新铸币的控制者，管理员无法保证分配奖励的正常进行

争议：反矿池的解谜算法也许并不能抑制中心化，因为没有了矿池会让小矿工们不敢参与挖矿，只剩下大型挖矿团队

最理想的方案是小额度奖励每个找到低等难度解谜答案的矿工，让小矿工们在不需要组成矿池的前提下也能参与挖矿获利

 

### 权益证明和虚拟挖矿

**虚拟挖矿（virtual mining）**：直接将挖矿“算力”按比例分配给有权益证明的矿工，从而节省挖矿设备和能耗；理由是利益相关者会有强烈意愿成为系统的维护者

虚拟挖矿可以节省能源，同时也不会有ASIC

 

**点点币（Peecoin）**：于2012年启动，是第一个使用权益证明的另类币，它结合了工作量证明（PoW）与权益证明（PoS），“拥有量”以“币龄”为计价单位

**币龄（Coin age）**：币量x未被交易的时间

点点币区块中包含一种即能用于消耗币龄又能获得利息的交易，称为利息币（coinstake），利息币总和越大挖矿目标则越大，挖矿也越容易

 

权益的其他形式有：

1. 权益证明：不考虑币龄，会让最有钱的参与者总是最容易挖矿
2. 储量证明：用于铸造区块的货币会被冻结一定时间（与币龄的方案正好成镜像，矿工的收入都是来自不能使用货币去做其他事情的机会成本）

 

虚拟挖矿的缺点：

1. “无利害关系问题”（nothing-at-stake problem）或“股权粉碎攻击”（stake-grinding attacks）：不像真实的算力，虚拟挖矿中的筹码可以同时用于两个挖矿，这就降低了矿工尝试分叉的成本

   中心化的检查点、以太坊（Ethereum）的Slasher都是尝试解决上述问题的方案

   检查点：用于给节点更新主链，更新由指定私钥签发

   **Slasher**：在使用筹码挖矿时需要私钥签名这一前提下，若矿工使用相同的筹码去签署两个不连续的区块链，其他矿工可以在区块链上输入这两个签名，并拿走一部分筹码作为奖励

2. 蓄力：虚拟挖矿可积蓄大量筹码进行一次剧烈的攻击
3. 垄断：如果有一个拥有51%筹码的矿工持续挖矿，则会永远保持优势直到筹码慢慢接近100%