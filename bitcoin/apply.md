# 应用

### **应用一：比特币作为一个只能被添加的记录**

**安全时间戳（secure timestamp）：**在不披露具体内容的前提下，证明该内容于某时间点存在，并且这个证据具备永久性

实例：

1. 专利、创意的优先权
2. 工作完成的时间点
3. 完全公钥签名方案，盖伊福克斯签名方案（Guy Fawkes signature scheme）
4. 等…

方案：

1. 将内容的哈希函数值作为输出地址，创建一笔微小交易

   缺点是会产生永不能使用的比特币

2. 承诺币（CommitCoin）：将内容的哈希函数值作为私钥，创建一个微小交易，随后再将交易分两次交易回来，两次交易的随机源相同（利用了ECDSA的不良随机源漏洞）

   如此不会产生永不能使用的比特币

3. OP_RETURN交易

   OP_RETURN<H (data) >，允许输出80字节

   恶意用途：记录非法内容

 

**附着币（overlay currencies）**：利用比特币的共识机制，开发一种新币，将开发新币需要的所有数据写进比特币的区块链中；附着币的检查更依赖用户，故没有一个轻量级的SPV客户端

 

**合约币（Counterparty）**：一种比较优秀的附着币，功能更丰富比如智能合约、用户自定义货币等，API更丰富；但是，合约币有效率低和交易费规则受制于比特币的缺点

 

### **应用二：比特币作为一个“智能资产”**

利用比特币具有可追溯性

**染色币（Colored Coins）：**在一个被称为“发行”的交易里，嵌入一些额外的元数据来宣布某些比特币具备了特定的“颜色”，这些比特币就成为了染色币；染色币交易后仍能追溯到发布

实例：

1. 公司股票
2. 有形资产交易
3. 域名交易（有一种另类币叫域名币Namecoin是专门用于域名交易的）
4. 等…

方案：

1. 开放资产（OpenAsset）：利用P2SH发行，执行带有染色币的交易时必须嵌入一个有特殊标记的支出

 

### **应用三：比特币作为一个多方参与的安全博彩系统**

可扩展为一个强大的系统模式：各自都有敏感数据的互不信任的一群参与者，共同来执行一个程序，不仅仅是为了控制数据，还可以控制与之关联的资金

假设三个参与者A/B/C，想以相同的概率选择一个号码1/2/3，最终与结果相同者获胜，则方案步骤为：

1. 首先每个人选择一个大的随机数（x/y/z）

2. 为了杜绝某人在知晓其他人的随机值后改变自己的数字，大家只发布随机数对应的哈希值（H(x)/ H(y)/ H(z)）

3. 为了避免某人在知晓其他人的随机值后不公布自己的数字，所有参与者两两交换保证金：

   例如A支付给特定脚本一笔交易作为A给B的保证金，输出脚本如下：
   ```
   scriptPubKey:
        OP_IF
               <A_PubKey> OP_CHECKSIGVERIFY <B_PubKey> OP_CHECKSIG
        OP_ELSE 
              <A_PubKey> OP_CHECKSIGVERIFY OP_HASH <H(x)> OP_EQUAL
        OP_ENDIF
   ```
   然后A和B同时签名将保证金支付给B，但交易的nLock_Time=t，t>0（所有人需要在t时间内公布自己选择的随机数）
   ```
   scriptSig:
        <B_Signatrue> <A_Signatrue> 1
   ```
   A在公布x时，将保证金收回
   ```
   scriptSig:
        x <A_Signatrue> 0
   ```
   同样方法B给A保证金
4.  x/y/z都公布后，最终结果为(x+y+z)%3

 

### **应用四：比特币作为一个公共的随机源**

**密码学“信号塔”（cryptograph beacons）：**提供公共随机源的服务，它源源不断在固定频率产生随机数，没人可以预测

方案：

1. 在区块头部设置一个“随机数抽取器”（哈希函数），把所有的输入随机熵均匀压缩成一个随机字符串作为随机信号输出

   缺点是不能精确定时，操纵信号所需的代价可能太低

实例：

1. 抽奖：在比特币脚本中加入一个特殊的操作码来读取**某一个**（例如上一个区块或特定高度的区块）比特币信号塔的随机数，加上多回合的数据协议安全或有时效的函数，最后利用随机数将一个交易的输出分派到n个密钥中的一个，来达到抽奖的目的

 

### **应用五：比特币作为一个去中心化的预测市场和真实世界的数据源**

**预测市场方案：**

1. **未来币（Futurecoin）**

   CreateMarket( event_id, arbitrator_key, num_outcomes )

   BuyPortfolio( event_id )

   TradeShares( … )

   SellPortfolio( event_id )

   CloseMarket( event_id, outcome_id )

   **仲裁方案：**

   1. 中心化仲裁员

   2. 多个仲裁员

   3. 用户投票

   4. 矿工投票

   5. 实时数据供给（真实数据的数据源）

   **现实密钥（reality keys）**：
   
   1. 仲裁者制造出一组密钥，其中每个密钥签名一个事件的结果起到代表作用
   
   2. 仲裁者公布所有密钥的公钥
   
   3. 预测者们将各自的保证金发送到一个比特币输出
   
   4. 仲裁者公布正确结果对应的密钥的私钥
   
   仲裁会面临复杂的难预料的实际情况



### **交易委托方案：**

1. 让矿工撮合两个交易，自己将两者的差额留下作为交易费



### 另类币

**初始分配：**在发布新的另类币前预先分配一部分货币，用于激励拥有人对新币作出贡献，也用于分散所有权避免集中持有

方案：

1. 指定预留
2. 利用比特币的销毁证明，可确保1个新币最多值1个比特币
3. 利用比特币指定高度区块中未消费的输出作为输入另类币的输入
4. 通过邮箱或社交账户捐赠

案例：

域名币（Namecoin）：一个基于比特币新建创世区块的域名（Name/Value）系统，以提供一个去中心化的DNS为目的

莱特币（Litecoin）：基于Scrypt算法的刚性内存解谜

狗币（Dogecoin）：莱特币的翻版，突出的特点是其社区价值体系：消费、慷慨和非严格

 

**共同挖矿：**将另类币的区块哈希值或一个指向多个另类币的二叉哈希树放入比特币的币基交易的输入脚本中，从而迅速提升一个新的另类币的总体算力

共同挖矿时比特币与另类币的挖矿难度是相互独立的，另类币可以有自己的挖矿难度，也就代表可以有自己的平均解密周期（因为一些挖矿结果不能满足比特币的目标区间，但能满足另类币的目标区间，这些结果会被广播）

安全问题：

1. 攻击另类币的成本变低
2. 矿工有动机跳过交易验证环节

 

**交叉链：**不同币种间的交易

（可与安全博彩系统作比较）

1. 甲创建随机字符串x，h = H(x)

2. 甲创建存储A区块

   输入：甲的另类币

   输出脚本：甲签名与乙签名一起兑现  **or**  乙签名与xs.t.H(x) = <h>（承诺函数）

3. 甲创建再融资A区块

   输入：存储A

   输出：甲地址

   定时：T2

   输入脚本：甲签名+乙签名

4. 甲公布存储A

5. 乙创建存储B区块

   输入：乙的比特币

   输出脚本：甲签名与乙签名一起兑现  **or**  甲签名与xs.t.H(x) = <h>

6. 乙创建再融资B区块

   输入：存储B

   输出：乙地址

   定时：T1（T1 < T2）

   输入脚本：甲签名+乙签名

7. 乙公布存储B

8. 甲使用s兑换存储B（也就公布了s）

9. 乙使用s兑换存储A

   问题：

   - 协议复杂、不便和缓慢
   - 不能防范服务性攻击